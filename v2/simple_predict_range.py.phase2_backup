#!/usr/bin/env python3
"""
Simple Romanian Liga I Date Range Match Predictor

Direct prediction system that bypasses complex feature building and uses 
form-weighted heuristics for maximum accuracy and speed.
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import argparse
import sys
import glob
from typing import List, Dict, Tuple, Optional
import logging

# Add v2 to path
sys.path.append('.')

from patterns.registry import get_pattern_registry, clear_patterns
from patterns.romanian_patterns import register_romanian_patterns

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)


class SimpleBettingRecommendation:
    """Simple betting recommendation"""
    def __init__(self, match_id: str, home_team: str, away_team: str, 
                 pattern_name: str, bet_type: str, confidence: float, 
                 threshold: float, expected_value: float, reasoning: str,
                 kelly_stake: float = 1.0):  # IMPROVEMENT #11: Kelly Criterion stake
        self.match_id = match_id
        self.home_team = home_team
        self.away_team = away_team
        self.pattern_name = pattern_name
        self.bet_type = bet_type
        self.confidence = confidence
        self.threshold = threshold
        self.expected_value = expected_value
        self.reasoning = reasoning
        self.kelly_stake = kelly_stake  # Recommended stake size
        self.recommendation = "BET" if confidence >= threshold and expected_value > 0.05 else "NO BET"


class SimpleRomanianPredictor:
    """Simplified predictor using form-weighted heuristics"""
    
    def __init__(self):
                # Optimized thresholds - DISABLED losing patterns based on 90-day testing
        self.confidence_thresholds = {
            # PROVEN WINNERS - Keep these
            'total_over_8_5_corners': 0.65,  # 74.2% win rate, +21.9 units (90 days) â­
            'home_over_1_5_cards': 0.75,     # 66.7% win rate, +0.4 units (90 days) âœ…
            'away_over_1_5_cards': 0.75,     # Same logic as home cards
            'total_over_3_5_cards': 0.70,    # Combined cards pattern
            'total_over_4_5_cards': 0.75,
            
            # CORNER VARIATIONS - Test carefully
            'home_over_2_5_corners': 0.65,
            'home_over_3_5_corners': 0.70,
            'home_over_4_5_corners': 0.75,
            'away_over_2_5_corners': 0.65,
            'away_over_3_5_corners': 0.70,
            'total_over_7_5_corners': 0.68,
            'total_over_9_5_corners': 0.85,  # 40% win rate - very selective
            'total_over_10_5_corners': 0.90, # Ultra-selective
            'total_under_7_5_corners': 0.60,
            
            # DISABLED PATTERNS - 90-day data shows these lose money
            'both_teams_to_score': 0.99,         # 29.2% win rate, -10 units ðŸ’€ DISABLED
            'away_over_1_5_goals': 0.99,         # 0% win rate, -4 units ðŸ’€ DISABLED
            'total_over_3_5_goals': 0.99,        # 0% win rate, -1 unit ðŸ’€ DISABLED
            'home_over_0_5_goals': 0.85,         # 75% but loses due to low odds
            'away_over_0_5_goals': 0.85,
            'home_over_2_5_goals': 0.85,
            'total_under_2_5_goals': 0.70,
        }
        
        # Expected odds for different bet types
        self.expected_odds = {
            'over_0_5_goals': 1.20,
            'over_1_5_goals': 1.60, 
            'over_2_5_goals': 2.20,
            'over_3_5_goals': 3.80,
            'under_2_5_goals': 1.80,
            'btts': 1.85,
            'over_1_5_cards': 1.70,
            'over_2_5_cards': 2.80,
            'over_7_5_corners': 1.90,
            'over_8_5_corners': 2.30,
            'over_9_5_corners': 3.20,
            'over_10_5_corners': 4.50,
        }
    
    def get_team_recent_form(self, team: str, historical_data: pd.DataFrame) -> float:
        """Calculate recent form score with 3x weighting for last 5 matches"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(10)  # Last 10 matches for context
        
        if len(team_matches) == 0:
            return 1.5  # Average form
        
        form_points = []
        goals_performance = []
        
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            
            # Skip incomplete matches
            if pd.isna(match['FTHG']) or pd.isna(match['FTAG']):
                continue
                
            if is_home:
                goals_for = match['FTHG']
                goals_against = match['FTAG']
                if match.get('FTR') == 'H':
                    points = 3
                elif match.get('FTR') == 'D':
                    points = 1
                else:
                    points = 0
            else:
                goals_for = match['FTAG']
                goals_against = match['FTHG']
                if match.get('FTR') == 'A':
                    points = 3
                elif match.get('FTR') == 'D':
                    points = 1
                else:
                    points = 0
            
            form_points.append(points)
            goals_performance.append(goals_for - goals_against)
        
        if not form_points:
            return 1.5
        
        # Weight recent matches more heavily (last 5 matches count 3x)
        num_matches = len(form_points)
        weights = []
        for i in range(num_matches):
            if i >= num_matches - 5:  # Last 5 matches
                weights.append(3.0)
            else:
                weights.append(1.0)
        
        # Calculate form score
        avg_points = np.average(form_points, weights=weights)
        avg_goal_diff = np.average(goals_performance, weights=weights)
        
        # Combine points and goal performance
        form_score = avg_points + (avg_goal_diff * 0.2)
        return max(0.0, min(3.5, form_score))
    
    def get_corner_momentum(self, team: str, historical_data: pd.DataFrame) -> float:
        """Get recent corner trend - positive means increasing corners"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(10)
        
        # Remove incomplete matches
        team_matches = team_matches.dropna(subset=['HC', 'AC'])
        
        if len(team_matches) < 6:
            return 0.0  # Neutral momentum
        
        corners_involved = []
        for _, match in team_matches.iterrows():
            # Total corners in matches this team participated in
            corners = match['HC'] + match['AC']
            corners_involved.append(corners)
        
        # Compare recent 3 matches vs previous 3 matches
        if len(corners_involved) >= 6:
            recent_avg = np.mean(corners_involved[-3:])
            older_avg = np.mean(corners_involved[-6:-3])
            momentum = recent_avg - older_avg
        else:
            momentum = 0.0
        
        return momentum
    
    def get_team_corner_style(self, team: str, historical_data: pd.DataFrame) -> Dict:
        """Analyze team's corner generation style - possession-based teams get more corners"""
        team_home_matches = historical_data[historical_data['HomeTeam'] == team].tail(8)
        team_away_matches = historical_data[historical_data['AwayTeam'] == team].tail(8)
        
        # Remove incomplete
        team_home_matches = team_home_matches.dropna(subset=['HC', 'AC'])
        team_away_matches = team_away_matches.dropna(subset=['HC', 'AC'])
        
        home_corners_for = team_home_matches['HC'].mean() if len(team_home_matches) > 0 else 4.5
        home_corners_against = team_home_matches['AC'].mean() if len(team_home_matches) > 0 else 4.5
        away_corners_for = team_away_matches['AC'].mean() if len(team_away_matches) > 0 else 4.0
        away_corners_against = team_away_matches['HC'].mean() if len(team_away_matches) > 0 else 4.5
        
        # Calculate corner differential (attacking teams generate more)
        home_differential = home_corners_for - home_corners_against
        away_differential = away_corners_for - away_corners_against
        
        return {
            'home_corners_for_avg': home_corners_for,
            'home_corners_against_avg': home_corners_against,
            'away_corners_for_avg': away_corners_for,
            'away_corners_against_avg': away_corners_against,
            'home_differential': home_differential,
            'away_differential': away_differential,
            'is_attacking_style': (home_differential + away_differential) > 0.5  # Positive differential
        }
    
    def get_recent_card_performance(self, team: str, historical_data: pd.DataFrame) -> float:
        """Get recent card performance with heavy weighting on last 5 matches"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(8)
        
        # Remove incomplete matches
        team_matches = team_matches.dropna(subset=['HY', 'AY'])
        
        if len(team_matches) == 0:
            return 2.0  # Default average
        
        cards_received = []
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            if is_home:
                cards = match['HY']
            else:
                cards = match['AY']
            cards_received.append(cards)
        
        # Weight last 5 matches more heavily
        weights = []
        for i in range(len(cards_received)):
            if i >= len(cards_received) - 5:  # Last 5 matches
                weights.append(3.0)
            else:
                weights.append(1.0)
        
        return np.average(cards_received, weights=weights) if cards_received else 2.0
    
    def get_btts_goal_form(self, team: str, historical_data: pd.DataFrame) -> Dict:
        """Get team's recent goal scoring and conceding form for BTTS analysis"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(8)
        
        # Remove incomplete matches
        team_matches = team_matches.dropna(subset=['FTHG', 'FTAG'])
        
        if len(team_matches) == 0:
            return {'goals_scored_avg': 1.2, 'goals_conceded_avg': 1.2, 'btts_rate': 0.5}
        
        goals_scored = []
        goals_conceded = []
        btts_matches = 0
        
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            if is_home:
                goals_scored.append(match['FTHG'])
                goals_conceded.append(match['FTAG'])
            else:
                goals_scored.append(match['FTAG'])
                goals_conceded.append(match['FTHG'])
            
            # Count BTTS occurrences
            if match['FTHG'] > 0 and match['FTAG'] > 0:
                btts_matches += 1
        
        # Weight last 5 matches more heavily (3x weighting)
        num_matches = len(goals_scored)
        weights = []
        for i in range(num_matches):
            if i >= num_matches - 5:  # Last 5 matches
                weights.append(3.0)
            else:
                weights.append(1.0)
        
        weights = np.array(weights)
        
        return {
            'goals_scored_avg': np.average(goals_scored, weights=weights) if goals_scored else 1.2,
            'goals_conceded_avg': np.average(goals_conceded, weights=weights) if goals_conceded else 1.2,
            'btts_rate': btts_matches / len(team_matches) if len(team_matches) > 0 else 0.5,
            'sample_size': len(team_matches)
        }
    
    def get_season_adjustment(self, home_team: str, away_team: str, historical_data: pd.DataFrame) -> float:
        """
        IMPROVEMENT #10: Time-based season pattern adjustment
        Adjusts confidence based on where we are in the season
        """
        # Count matches played by each team to determine season stage
        home_matches = len(historical_data[
            (historical_data['HomeTeam'] == home_team) | 
            (historical_data['AwayTeam'] == home_team)
        ])
        
        away_matches = len(historical_data[
            (historical_data['HomeTeam'] == away_team) | 
            (historical_data['AwayTeam'] == away_team)
        ])
        
        avg_matches = (home_matches + away_matches) / 2
        
        # Romanian Liga I typically has 34 matches per season (16 teams)
        # Early season: 0-6 matches
        # Mid season: 7-27 matches  
        # Late season: 28+ matches
        
        if avg_matches <= 6:
            # EARLY SEASON: Higher variance, less reliable patterns
            # Be more cautious - increase threshold
            return 0.08  # Add 8% to threshold (more selective)
        elif avg_matches <= 27:
            # MID SEASON: Peak form, most reliable patterns
            # Optimal confidence - slight decrease in threshold
            return -0.03  # Reduce 3% from threshold (more confident)
        else:
            # LATE SEASON: Motivation/pressure factors
            # Moderate caution - slight increase
            return 0.02  # Add 2% to threshold (slightly more selective)
    
    def calculate_kelly_stake(self, confidence: float, odds: float, bankroll: float = 100.0) -> float:
        """
        IMPROVEMENT #11: Kelly Criterion bankroll management
        Calculate optimal stake size based on edge and confidence
        
        Kelly Formula: f = (bp - q) / b
        where:
        - f = fraction of bankroll to bet
        - b = odds - 1 (net odds)
        - p = probability of winning (confidence)
        - q = probability of losing (1 - confidence)
        """
        # Use fractional Kelly (25% of full Kelly) for risk management
        b = odds - 1.0  # Net odds
        p = confidence
        q = 1.0 - confidence
        
        # Full Kelly fraction
        if b <= 0:  # Safety check
            return 0.5  # Min bet
        
        kelly_fraction = (b * p - q) / b
        
        # Apply 25% fractional Kelly for safety (recommended for betting)
        conservative_kelly = kelly_fraction * 0.25
        
        # Cap at 3% of bankroll (max risk per bet)
        # Floor at 0.5% of bankroll (min bet size)
        stake_fraction = max(0.005, min(0.03, conservative_kelly))
        
        stake_units = stake_fraction * bankroll
        
        return round(stake_units, 2)
    
    def get_adaptive_lookback_days(self, home_team: str, away_team: str, historical_data: pd.DataFrame) -> int:
        """
        IMPROVEMENT #5: Adaptive lookback period
        Dynamically choose optimal historical window based on form volatility
        
        Logic:
        - Unstable/high variance form â†’ Use 60-90 days (more data for stability)
        - Consistent form â†’ Use 10-14 days (recent form is reliable)
        - Mid-season stable â†’ Use 45 days (balanced)
        - Early/late season â†’ Use 90+ days (need more context)
        """
        # Get match counts to determine season stage
        home_matches_count = len(historical_data[
            (historical_data['HomeTeam'] == home_team) | 
            (historical_data['AwayTeam'] == home_team)
        ])
        
        away_matches_count = len(historical_data[
            (historical_data['HomeTeam'] == away_team) | 
            (historical_data['AwayTeam'] == away_team)
        ])
        
        avg_matches = (home_matches_count + away_matches_count) / 2
        
        # Calculate form volatility (how much results vary)
        home_volatility = self._calculate_form_volatility(home_team, historical_data)
        away_volatility = self._calculate_form_volatility(away_team, historical_data)
        avg_volatility = (home_volatility + away_volatility) / 2
        
        # DECISION LOGIC:
        
        # Early season (0-6 matches) â†’ Need more data
        if avg_matches <= 6:
            return 90  # Maximum lookback for stability
        
        # Late season (28+ matches) â†’ Pressure/motivation changes
        elif avg_matches >= 28:
            return 60  # Moderate lookback, balance recent + historical
        
        # Mid-season with HIGH volatility â†’ Need stability
        elif avg_volatility >= 1.5:
            return 60  # More data to smooth out variance
        
        # Mid-season with LOW volatility (consistent form) â†’ Trust recent
        elif avg_volatility <= 0.8:
            return 14  # Recent form is reliable, use it!
        
        # Mid-season with MODERATE volatility
        else:
            return 45  # Balanced approach
    
    def _calculate_form_volatility(self, team: str, historical_data: pd.DataFrame) -> float:
        """Calculate how much a team's results vary (standard deviation of points)"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(10)
        
        if len(team_matches) < 5:
            return 1.0  # Default moderate volatility
        
        points_list = []
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            
            if pd.isna(match.get('FTR')):
                continue
                
            if is_home:
                if match['FTR'] == 'H':
                    points = 3
                elif match['FTR'] == 'D':
                    points = 1
                else:
                    points = 0
            else:
                if match['FTR'] == 'A':
                    points = 3
                elif match['FTR'] == 'D':
                    points = 1
                else:
                    points = 0
            
            points_list.append(points)
        
        if len(points_list) < 3:
            return 1.0
        
        # Calculate standard deviation (volatility measure)
        volatility = np.std(points_list)
        return volatility
    
    def get_league_position_adjustment(self, home_team: str, away_team: str, historical_data: pd.DataFrame) -> Dict:
        """
        IMPROVEMENT #6: League position context
        Adjust patterns based on estimated league standings and pressure
        
        Returns adjustments for different pattern types based on team positions
        """
        # Estimate current league positions
        home_position = self._estimate_league_position(home_team, historical_data)
        away_position = self._estimate_league_position(away_team, historical_data)
        
        adjustments = {
            'corner_boost': 0.0,
            'card_boost': 0.0,
            'goal_boost': 0.0,
            'threshold_adjustment': 0.0
        }
        
        # Romanian Liga I has 16 teams
        # Top 6: European spots (title race pressure)
        # Bottom 3: Relegation zone (survival pressure)
        
        # TITLE RACE TEAMS (Top 6)
        if home_position <= 6 or away_position <= 6:
            adjustments['corner_boost'] = 0.05  # More attacking = more corners
            adjustments['goal_boost'] = 0.03  # Higher scoring ambition
            
            # Both top teams = highly competitive
            if home_position <= 6 and away_position <= 6:
                adjustments['card_boost'] = 0.05  # Competitive match = more cards
                adjustments['corner_boost'] = 0.08  # Both attack = lots of corners
        
        # RELEGATION BATTLE (Bottom 3)
        if home_position >= 14 or away_position >= 14:
            adjustments['card_boost'] = 0.08  # Desperate = more fouls/cards
            adjustments['goal_boost'] = -0.03  # More defensive play
            
            # Both fighting relegation = scrappy match
            if home_position >= 14 and away_position >= 14:
                adjustments['card_boost'] = 0.12  # Very physical match
                adjustments['corner_boost'] = -0.05  # Defensive = fewer corners
        
        # TOP vs BOTTOM (mismatch)
        if (home_position <= 6 and away_position >= 14) or (away_position <= 6 and home_position >= 14):
            adjustments['goal_boost'] = 0.05  # Likely one-sided
            adjustments['corner_boost'] = 0.06  # Dominant team = more corners
            adjustments['threshold_adjustment'] = -0.03  # More predictable outcome
        
        # MID-TABLE CLASH (positions 7-13)
        if 7 <= home_position <= 13 and 7 <= away_position <= 13:
            adjustments['threshold_adjustment'] = 0.05  # Less predictable, more cautious
        
        return adjustments
    
    def _estimate_league_position(self, team: str, historical_data: pd.DataFrame) -> int:
        """
        Estimate team's current league position based on points and goal difference
        Simple calculation: points per game Ã— matches played
        """
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ]
        
        if len(team_matches) < 3:
            return 8  # Assume mid-table if insufficient data
        
        total_points = 0
        goal_difference = 0
        
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            
            if pd.isna(match.get('FTR')) or pd.isna(match.get('FTHG')) or pd.isna(match.get('FTAG')):
                continue
            
            if is_home:
                if match['FTR'] == 'H':
                    total_points += 3
                elif match['FTR'] == 'D':
                    total_points += 1
                goal_difference += match['FTHG'] - match['FTAG']
            else:
                if match['FTR'] == 'A':
                    total_points += 3
                elif match['FTR'] == 'D':
                    total_points += 1
                goal_difference += match['FTAG'] - match['FTHG']
        
        matches_played = len(team_matches)
        points_per_game = total_points / matches_played if matches_played > 0 else 1.0
        
        # Estimate position based on points per game
        # Top teams: ~2.0+ PPG (Champions pace)
        # European spots: ~1.5-2.0 PPG
        # Mid-table: ~1.0-1.5 PPG
        # Relegation fight: ~0.8-1.0 PPG
        # Bottom: <0.8 PPG
        
        if points_per_game >= 2.2:
            return 1  # Title contenders
        elif points_per_game >= 1.9:
            return 3  # Top 3
        elif points_per_game >= 1.5:
            return 6  # European spots
        elif points_per_game >= 1.2:
            return 9  # Upper mid-table
        elif points_per_game >= 1.0:
            return 11  # Mid-table
        elif points_per_game >= 0.8:
            return 14  # Relegation fight
        else:
            return 16  # Bottom of table
    
    def get_referee_adjustment(self, referee_name: str, pattern_name: str, historical_data: pd.DataFrame) -> float:
        """
        IMPROVEMENT #9: Referee analysis
        Adjust confidence based on referee's historical card tendencies
        
        Note: Currently placeholder as Romanian data doesn't include referee info
        Can be enhanced when referee data becomes available
        """
        # Check if we have referee column in data
        if 'Referee' not in historical_data.columns or pd.isna(referee_name):
            return 0.0  # No adjustment if no referee data
        
        # Get referee's historical matches
        ref_matches = historical_data[historical_data['Referee'] == referee_name]
        
        if len(ref_matches) < 5:
            return 0.0  # Need at least 5 matches for reliable stats
        
        # Analyze card patterns for this referee
        if 'card' in pattern_name.lower():
            # Calculate referee's average cards per match
            total_cards = 0
            match_count = 0
            
            for _, match in ref_matches.iterrows():
                if pd.notna(match.get('HY')) and pd.notna(match.get('AY')):
                    total_cards += match['HY'] + match['AY']
                    match_count += 1
            
            if match_count == 0:
                return 0.0
            
            avg_cards_per_match = total_cards / match_count
            
            # Liga I average is ~4 cards per match
            # Strict refs: 5.5+ cards â†’ Boost card pattern confidence
            # Lenient refs: <3 cards â†’ Reduce card pattern confidence
            
            if avg_cards_per_match >= 5.5:
                return 0.15  # +15% confidence boost for strict ref
            elif avg_cards_per_match >= 4.5:
                return 0.08  # +8% for moderately strict
            elif avg_cards_per_match <= 3.0:
                return -0.20  # -20% for lenient ref (avoid card bets)
            elif avg_cards_per_match <= 3.5:
                return -0.10  # -10% for moderately lenient
            else:
                return 0.0  # Average referee
        
        # For corner patterns - some refs let play flow more
        elif 'corner' in pattern_name.lower():
            # Refs who call fewer fouls = more corners (play continues)
            # This is inverse relationship with cards
            total_cards = 0
            match_count = 0
            
            for _, match in ref_matches.iterrows():
                if pd.notna(match.get('HY')) and pd.notna(match.get('AY')):
                    total_cards += match['HY'] + match['AY']
                    match_count += 1
            
            if match_count == 0:
                return 0.0
            
            avg_cards = total_cards / match_count
            
            # Lenient refs (fewer cards) = more flow = potentially more corners
            if avg_cards <= 3.0:
                return 0.05  # Slight boost for flowing game
            else:
                return 0.0
        
        return 0.0  # No adjustment for other patterns
    
    def get_adaptive_threshold(self, pattern_name: str, home_team: str, away_team: str, historical_data: pd.DataFrame) -> float:
        """Get adaptive threshold based on team form and pattern performance"""
        base_threshold = self.confidence_thresholds.get(pattern_name, 0.70)
        
        # IMPROVEMENT #10: Time-based season adjustment
        season_adjustment = self.get_season_adjustment(home_team, away_team, historical_data)
        
        # DYNAMIC ADJUSTMENT: Check recent pattern performance
        # This simulates monthly recalibration
        recent_matches = historical_data.tail(20)  # Last 20 matches as proxy
        
        # Get recent team form
        home_form = self.get_team_recent_form(home_team, historical_data)
        away_form = self.get_team_recent_form(away_team, historical_data)
        avg_form = (home_form + away_form) / 2
        
        # Form-based adjustment
        if avg_form >= 2.0:  # Excellent form
            threshold_adjustment = -0.03  # Lower threshold for good form teams
        elif avg_form >= 1.5:  # Good form
            threshold_adjustment = -0.01
        elif avg_form <= 0.8:  # Poor form
            threshold_adjustment = 0.08  # Higher threshold for poor form
        elif avg_form <= 1.0:  # Below average
            threshold_adjustment = 0.03
        else:
            threshold_adjustment = 0.0
        
        # Add season adjustment
        threshold_adjustment += season_adjustment
        
        # IMPROVEMENT #6: League position threshold adjustment
        position_adjustments = self.get_league_position_adjustment(home_team, away_team, historical_data)
        threshold_adjustment += position_adjustments['threshold_adjustment']
        
        # Pattern-specific adjustments based on style
        if 'corner' in pattern_name.lower():
            # Check if teams have attacking style
            home_style = self.get_team_corner_style(home_team, historical_data)
            away_style = self.get_team_corner_style(away_team, historical_data)
            
            if home_style['is_attacking_style'] and away_style['is_attacking_style']:
                threshold_adjustment -= 0.05  # Both attack = lower threshold
            
        if 'card' in pattern_name.lower():
            form_variance = abs(home_form - away_form)
            if form_variance >= 1.0:  # Big gap = competitive match
                threshold_adjustment -= 0.03
        
        return max(0.50, min(0.95, base_threshold + threshold_adjustment))
    
    def get_ensemble_confidence_boost(self, pattern_name: str, base_confidence: float, 
                                      home_team: str, away_team: str, historical_data: pd.DataFrame) -> float:
        """Ensemble voting: boost confidence when multiple signals agree"""
        boost = 0.0
        agreement_count = 0
        
        # Signal 1: Base confidence (heuristic model)
        if base_confidence >= 0.70:
            agreement_count += 1
        
        # Signal 2: Recent form alignment
        home_form = self.get_team_recent_form(home_team, historical_data)
        away_form = self.get_team_recent_form(away_team, historical_data)
        
        if 'corner' in pattern_name:
            home_style = self.get_team_corner_style(home_team, historical_data)
            away_style = self.get_team_corner_style(away_team, historical_data)
            
            # Signal 2: Style agreement
            if home_style['is_attacking_style'] or away_style['is_attacking_style']:
                agreement_count += 1
            
            # Signal 3: Momentum agreement
            home_momentum = self.get_corner_momentum(home_team, historical_data)
            away_momentum = self.get_corner_momentum(away_team, historical_data)
            if home_momentum > 0 and away_momentum > 0:
                agreement_count += 1
        
        elif 'card' in pattern_name:
            # Signal 2: Recent card performance
            if 'home' in pattern_name:
                recent_cards = self.get_recent_card_performance(home_team, historical_data)
                if recent_cards >= 2.0:
                    agreement_count += 1
            elif 'away' in pattern_name:
                recent_cards = self.get_recent_card_performance(away_team, historical_data)
                if recent_cards >= 2.0:
                    agreement_count += 1
        
        # Ensemble boost based on agreement
        if agreement_count >= 3:
            boost = 0.08  # Strong consensus
        elif agreement_count == 2:
            boost = 0.04  # Moderate agreement
        elif agreement_count == 1:
            boost = 0.0   # Weak - no boost
        else:
            boost = -0.05  # Disagreement - penalty
        
        return boost
    
    def estimate_pattern_confidence(self, pattern_name: str, home_team: str, away_team: str, historical_data: pd.DataFrame) -> float:
        """Estimate confidence using form-weighted team statistics with enhanced filters"""
        
        # Get team statistics with form weighting
        home_stats = self.get_weighted_team_stats(home_team, historical_data)
        away_stats = self.get_weighted_team_stats(away_team, historical_data)
        
        # Enhanced corner momentum check for higher accuracy
        if 'corner' in pattern_name:
            home_corner_momentum = self.get_corner_momentum(home_team, historical_data)
            away_corner_momentum = self.get_corner_momentum(away_team, historical_data)
            
            # Both teams should show positive corner activity for corner bets
            if home_corner_momentum < -0.5 or away_corner_momentum < -0.5:
                # Reduce confidence if either team shows negative corner momentum
                momentum_penalty = 0.15
            else:
                momentum_penalty = 0.0
        
        # Pattern-specific confidence estimation (Realistic for Romanian Liga I)
        if 'home_over' in pattern_name and 'goals' in pattern_name:
            if '0_5' in pattern_name:
                # Most teams score at home - generous but realistic
                confidence = min(0.90, home_stats['goals_scored_avg'] * 0.50 + 0.25)
            elif '2_5' in pattern_name:
                # Scoring 3+ goals rare - very conservative
                confidence = min(0.85, home_stats['goals_scored_avg'] * 0.30 + 0.15)
            else:
                confidence = 0.60
                
        elif 'away_over' in pattern_name and 'goals' in pattern_name:
            if '0_5' in pattern_name:
                # Away teams scoring at least 1 - moderate formula
                confidence = min(0.85, away_stats['goals_scored_avg'] * 0.48 + 0.22)
            elif '1_5' in pattern_name:
                # Away teams scoring 2+ - conservative
                confidence = min(0.80, away_stats['goals_scored_avg'] * 0.40 + 0.20)
            elif '2_5' in pattern_name:
                # Away teams scoring 3+ - very rare
                confidence = min(0.75, away_stats['goals_scored_avg'] * 0.30 + 0.15)
            else:
                confidence = 0.60
                
        elif 'total_over' in pattern_name and 'goals' in pattern_name:
            total_avg = home_stats['goals_scored_avg'] + away_stats['goals_scored_avg']
            if '1_5' in pattern_name:
                # Over 1.5 total goals - common in Liga I
                confidence = min(0.88, total_avg * 0.30 + 0.25)
            elif '2_5' in pattern_name:
                # Over 2.5 total goals - moderate threshold
                confidence = min(0.85, total_avg * 0.25 + 0.20)
            elif '3_5' in pattern_name:
                # High scoring games RARE in Liga I - conservative
                confidence = min(0.80, (total_avg - 2.5) * 0.20 + 0.40)
            else:
                confidence = 0.60
                
        elif 'total_under_2_5_goals' in pattern_name:
            total_avg = home_stats['goals_scored_avg'] + away_stats['goals_scored_avg']
            # Liga I is defensive - generous under formula
            confidence = max(0.45, min(0.88, 1.00 - (total_avg * 0.20)))
            
        elif 'both_teams_to_score' in pattern_name:
            # Enhanced BTTS analysis with goal form
            home_btts_form = self.get_btts_goal_form(home_team, historical_data)
            away_btts_form = self.get_btts_goal_form(away_team, historical_data)
            
            # Base confidence from goal scoring ability
            scoring_factor = (home_btts_form['goals_scored_avg'] * away_btts_form['goals_scored_avg']) * 0.25 + 0.20
            
            # Boost confidence if both teams have good scoring form AND concede goals
            if (home_btts_form['goals_scored_avg'] >= 1.0 and away_btts_form['goals_scored_avg'] >= 1.0 and
                home_btts_form['goals_conceded_avg'] >= 0.8 and away_btts_form['goals_conceded_avg'] >= 0.8):
                defensive_vulnerability_bonus = 0.15
            else:
                defensive_vulnerability_bonus = 0.0
            
            # Historical BTTS rate factor
            avg_btts_rate = (home_btts_form['btts_rate'] + away_btts_form['btts_rate']) / 2
            btts_history_factor = avg_btts_rate * 0.20
            
            # Penalty for insufficient data
            min_sample_size = min(home_btts_form['sample_size'], away_btts_form['sample_size'])
            if min_sample_size < 6:
                data_penalty = 0.10
            else:
                data_penalty = 0.0
            
            # Home advantage bonus for BTTS (home teams often score more in Liga I)
            if home_btts_form['goals_scored_avg'] > away_btts_form['goals_scored_avg'] * 1.2:
                home_advantage_bonus = 0.05
            else:
                home_advantage_bonus = 0.0
            
            # Ultra-selective penalty: if away team has very poor scoring form
            if away_btts_form['goals_scored_avg'] < 0.8:
                away_scoring_penalty = 0.15
            else:
                away_scoring_penalty = 0.0
            
            confidence = min(0.90, scoring_factor + defensive_vulnerability_bonus + btts_history_factor + home_advantage_bonus - data_penalty - away_scoring_penalty)
            
        elif 'corner' in pattern_name:
            # ADVANCED CORNER ANALYSIS - Team style + momentum
            home_corner_style = self.get_team_corner_style(home_team, historical_data)
            away_corner_style = self.get_team_corner_style(away_team, historical_data)
            
            # Use style-aware averages
            if 'home' in pattern_name:
                total_corners = home_corner_style['home_corners_for_avg']
            elif 'away' in pattern_name:
                total_corners = away_corner_style['away_corners_for_avg']
            else:
                # Total corners - combine both teams' averages
                total_corners = home_corner_style['home_corners_for_avg'] + away_corner_style['away_corners_for_avg']
            
            # Base confidence calculation
            if '7_5' in pattern_name:
                base_confidence = min(0.85, (total_corners - 6) * 0.25 + 0.40)
            elif '8_5' in pattern_name:
                base_confidence = min(0.85, (total_corners - 7) * 0.25 + 0.35)
            elif '9_5' in pattern_name:
                base_confidence = min(0.80, (total_corners - 8) * 0.22 + 0.30)
            elif '10_5' in pattern_name:
                base_confidence = min(0.75, (total_corners - 9) * 0.20 + 0.25)
            else:
                base_confidence = 0.60
            
            # STYLE BONUS: Attacking teams generate more corners
            if home_corner_style['is_attacking_style'] and away_corner_style['is_attacking_style']:
                style_bonus = 0.10  # Both teams attack = lots of corners
            elif home_corner_style['is_attacking_style'] or away_corner_style['is_attacking_style']:
                style_bonus = 0.05  # One attacking team
            else:
                style_bonus = 0.0
            
            # Momentum check
            home_corner_momentum = self.get_corner_momentum(home_team, historical_data)
            away_corner_momentum = self.get_corner_momentum(away_team, historical_data)
            
            # Initialize momentum adjustments
            momentum_penalty = 0.0
            momentum_bonus = 0.0
            
            # Both teams should show positive corner activity for corner bets
            if home_corner_momentum < -0.5 or away_corner_momentum < -0.5:
                momentum_penalty = 0.15
            elif home_corner_momentum > 1.0 and away_corner_momentum > 1.0:
                momentum_bonus = 0.08  # Both trending up
            
            # Apply all adjustments
            confidence = max(0.30, base_confidence + style_bonus + momentum_bonus - momentum_penalty)
                
        elif 'card' in pattern_name:
            if 'home' in pattern_name:
                # Enhanced card confidence with venue and competition factors
                base_card_confidence = min(0.85, home_stats.get('cards_for_avg', 2.0) * 0.25 + 0.30)
                
                # Check recent card trends (last 5 matches)
                recent_card_performance = self.get_recent_card_performance(home_team, historical_data)
                
                # Adjust confidence based on recent performance
                if recent_card_performance > 2.5:  # High recent cards
                    card_adjustment = 0.10
                elif recent_card_performance < 1.0:  # Low recent cards
                    card_adjustment = -0.20
                else:
                    card_adjustment = 0.0
                
                confidence = max(0.30, min(0.90, base_card_confidence + card_adjustment))
                
            elif 'away' in pattern_name:
                # Away team card confidence (similar logic)
                base_card_confidence = min(0.85, away_stats.get('cards_for_avg', 2.0) * 0.25 + 0.30)
                
                # Check recent card trends
                recent_card_performance = self.get_recent_card_performance(away_team, historical_data)
                
                # Adjust confidence based on recent performance
                if recent_card_performance > 2.5:
                    card_adjustment = 0.10
                elif recent_card_performance < 1.0:
                    card_adjustment = -0.20
                else:
                    card_adjustment = 0.0
                
                confidence = max(0.30, min(0.90, base_card_confidence + card_adjustment))
                
            elif 'total' in pattern_name:
                # Total cards - combined team discipline
                home_card_avg = home_stats.get('cards_for_avg', 2.0)
                away_card_avg = away_stats.get('cards_for_avg', 2.0)
                total_card_avg = home_card_avg + away_card_avg
                
                # Total over 3.5 or 4.5 cards
                if '3_5' in pattern_name:
                    base_confidence = min(0.85, (total_card_avg - 3.0) * 0.25 + 0.40)
                elif '4_5' in pattern_name:
                    base_confidence = min(0.80, (total_card_avg - 4.0) * 0.22 + 0.35)
                else:
                    base_confidence = 0.60
                
                # Recent form adjustment for both teams
                home_recent = self.get_recent_card_performance(home_team, historical_data)
                away_recent = self.get_recent_card_performance(away_team, historical_data)
                combined_recent = home_recent + away_recent
                
                if combined_recent > 5.0:  # Both teams getting lots of cards
                    card_adjustment = 0.10
                elif combined_recent < 2.5:  # Both teams disciplined
                    card_adjustment = -0.15
                else:
                    card_adjustment = 0.0
                
                confidence = max(0.30, min(0.90, base_confidence + card_adjustment))
            else:
                confidence = 0.60
        else:
            confidence = 0.60
        
        # PHASE 2 IMPROVEMENTS: Apply league position and referee adjustments
        
        # IMPROVEMENT #6: League position context
        position_adjustments = self.get_league_position_adjustment(home_team, away_team, historical_data)
        
        if 'corner' in pattern_name:
            confidence += position_adjustments['corner_boost']
        elif 'card' in pattern_name:
            confidence += position_adjustments['card_boost']
        elif 'goal' in pattern_name:
            confidence += position_adjustments['goal_boost']
        
        # IMPROVEMENT #9: Referee analysis (if referee data available)
        referee_name = None  # Placeholder - set from match data when available
        referee_adjustment = self.get_referee_adjustment(referee_name, pattern_name, historical_data)
        confidence += referee_adjustment
        
        # ENSEMBLE BOOST: Apply multi-signal voting
        ensemble_boost = self.get_ensemble_confidence_boost(pattern_name, confidence, home_team, away_team, historical_data)
        final_confidence = confidence + ensemble_boost
        
        return max(0.30, min(0.95, final_confidence))
    
    def get_weighted_team_stats(self, team: str, historical_data: pd.DataFrame) -> Dict:
        """Get team stats with ultra-recent form weighting (3 matches at 5x, next 5 at 2x)"""
        team_matches = historical_data[
            (historical_data['HomeTeam'] == team) | 
            (historical_data['AwayTeam'] == team)
        ].tail(15)
        
        # Remove incomplete matches
        team_matches = team_matches.dropna(subset=['FTHG', 'FTAG'])
        
        if len(team_matches) == 0:
            return {'goals_scored_avg': 1.2, 'corners_for_avg': 4.5, 'cards_for_avg': 2.0}
        
        # Create ultra-recent weights (last 3 matches = 5x, next 5 matches = 2x, older = 1x)
        num_matches = len(team_matches)
        weights = []
        for i in range(num_matches):
            if i >= num_matches - 3:  # Last 3 matches
                weights.append(5.0)
            elif i >= num_matches - 8:  # Next 5 matches (8 total)
                weights.append(2.0)
            else:
                weights.append(1.0)
        
        weights = np.array(weights)
        
        goals_for = []
        corners_for = []
        cards_for = []
        
        for _, match in team_matches.iterrows():
            is_home = match['HomeTeam'] == team
            if is_home:
                goals_for.append(match['FTHG'])
                corners_for.append(match.get('HC', 4))
                cards_for.append(match.get('HY', 2))
            else:
                goals_for.append(match['FTAG'])
                corners_for.append(match.get('AC', 4))
                cards_for.append(match.get('AY', 2))
        
        return {
            'goals_scored_avg': np.average(goals_for, weights=weights) if goals_for else 1.2,
            'corners_for_avg': np.average(corners_for, weights=weights) if corners_for else 4.5,
            'cards_for_avg': np.average(cards_for, weights=weights) if cards_for else 2.0
        }
    
    def get_expected_odds(self, pattern_name: str) -> float:
        """Get expected odds for a pattern"""
        for bet_type, odds in self.expected_odds.items():
            if bet_type in pattern_name:
                return odds
        return 2.00
    
    def predict_match(self, home_team: str, away_team: str, historical_data: pd.DataFrame) -> List[SimpleBettingRecommendation]:
        """Predict betting opportunities for a match with enhanced accuracy filters"""
        recommendations = []
        
        # Enhanced filter: Check minimum data availability for better accuracy
        home_matches = len(historical_data[(historical_data['HomeTeam'] == home_team) | 
                                          (historical_data['AwayTeam'] == home_team)])
        away_matches = len(historical_data[(historical_data['HomeTeam'] == away_team) | 
                                          (historical_data['AwayTeam'] == away_team)])
        
        # Require minimum match history for reliable predictions
        if home_matches < 8 or away_matches < 8:
            # Insufficient data - return conservative predictions only
            return recommendations
        
        # Test key patterns
        patterns_to_test = [
            ('total_over_8_5_corners', 'Total corners over 8.5'),
            ('home_over_0_5_goals', f'{home_team} over 0.5 goals'),
            ('both_teams_to_score', 'Both teams to score'),
            ('total_over_3_5_goals', 'Total goals over 3.5'),
            ('home_over_1_5_cards', f'{home_team} over 1.5 cards'),
            ('total_over_9_5_corners', 'Total corners over 9.5'),
            ('away_over_1_5_goals', f'{away_team} over 1.5 goals'),
        ]
        
        for pattern_name, bet_description in patterns_to_test:
            # Get adaptive threshold
            threshold = self.get_adaptive_threshold(pattern_name, home_team, away_team, historical_data)
            
            # Estimate confidence
            confidence = self.estimate_pattern_confidence(pattern_name, home_team, away_team, historical_data)
            
            # Calculate expected value
            expected_odds = self.get_expected_odds(pattern_name)
            expected_value = (confidence * expected_odds) - 1.0
            
            # Create reasoning
            if confidence >= threshold and expected_value > 0.05:
                reasoning = f"Strong form-based confidence {confidence:.1%}, EV: {expected_value:+.2%}"
            else:
                reasoning = f"Confidence {confidence:.1%} below adaptive threshold {threshold:.1%}"
            
            # IMPROVEMENT #11: Calculate Kelly stake
            expected_odds = self.expected_odds.get(pattern_name, 1.85)
            kelly_stake = self.calculate_kelly_stake(confidence, expected_odds, bankroll=100.0)
            
            recommendation = SimpleBettingRecommendation(
                match_id=f"{home_team}_{away_team}",
                home_team=home_team,
                away_team=away_team,
                pattern_name=pattern_name,
                bet_type=bet_description,
                confidence=confidence,
                threshold=threshold,
                expected_value=expected_value,
                reasoning=reasoning,
                kelly_stake=kelly_stake
            )
            
            recommendations.append(recommendation)
        
        return recommendations


def parse_date(date_str: str) -> datetime:
    """Parse date string in various formats"""
    formats = ["%Y-%m-%d", "%Y/%m/%d", "%d-%m-%Y", "%d/%m/%Y", "%m-%d-%Y", "%m/%d/%Y"]
    
    for fmt in formats:
        try:
            return datetime.strptime(date_str, fmt)
        except ValueError:
            continue
    
    raise ValueError(f"Unable to parse date: {date_str}. Use format YYYY-MM-DD")


def load_romanian_data() -> pd.DataFrame:
    """Load and process Romanian Liga I data"""
    print("ðŸ“‚ Loading Romanian Liga I data...")
    
    csv_files = glob.glob('data/liga1-romania/*.csv')
    if not csv_files:
        raise FileNotFoundError("No data files found")
    
    data_frames = []
    for file in csv_files:
        df = pd.read_csv(file)
        
        # Map to standard format
        df_mapped = pd.DataFrame({
            'HomeTeam': df['home_team_name'],
            'AwayTeam': df['away_team_name'],
            'FTHG': df['home_team_goal_count'],
            'FTAG': df['away_team_goal_count'],
            'HC': df['home_team_corner_count'],
            'AC': df['away_team_corner_count'],
            'HY': df['home_team_yellow_cards'],
            'AY': df['away_team_yellow_cards'],
            'Date': df['date_GMT'],
            'Status': df['status'],
            'Timestamp': df['timestamp']
        })
        
        # Add result for completed matches
        def get_result(row):
            if pd.isna(row['FTHG']) or pd.isna(row['FTAG']):
                return None
            return 'H' if row['FTHG'] > row['FTAG'] else ('A' if row['FTAG'] > row['FTHG'] else 'D')
        
        df_mapped['FTR'] = df_mapped.apply(get_result, axis=1)
        data_frames.append(df_mapped)
    
    combined_data = pd.concat(data_frames, ignore_index=True)
    combined_data = combined_data.dropna(subset=['HomeTeam', 'AwayTeam'])
    
    print(f"âœ… Loaded {len(combined_data)} total matches")
    return combined_data


def predict_date_range_matches(start_date: str, end_date: str):
    """Predict matches in date range using simplified approach"""
    
    # Parse dates
    start_dt = parse_date(start_date)
    end_dt = parse_date(end_date)
    
    if start_dt > end_dt:
        print("âŒ Error: Start date must be before end date")
        return
    
    print(f"\nðŸŽ¯ ROMANIAN LIGA I PREDICTIONS")
    print(f"ðŸ“… Date Range: {start_dt.strftime('%Y-%m-%d')} to {end_dt.strftime('%Y-%m-%d')}")
    print("=" * 60)
    
    # Load data
    all_data = load_romanian_data()
    
    # Filter matches
    all_data['DateTime'] = pd.to_datetime(all_data['Timestamp'], unit='s')
    mask = (all_data['DateTime'] >= start_dt) & (all_data['DateTime'] <= end_dt)
    matches_in_range = all_data[mask].copy()
    
    historical_data = all_data[all_data['Status'] == 'complete'].copy()
    future_matches = matches_in_range[matches_in_range['Status'] == 'incomplete'].copy()
    
    if len(future_matches) == 0:
        print("\nâš ï¸ No future matches found in date range")
        return
    
    print(f"\nðŸ“Š Analysis: {len(historical_data)} historical, {len(future_matches)} future matches")
    
    # Initialize predictor
    predictor = SimpleRomanianPredictor()
    
    # Process matches
    bet_recommendations = []
    all_results = []
    
    for _, match in future_matches.iterrows():
        recommendations = predictor.predict_match(
            match['HomeTeam'], match['AwayTeam'], historical_data
        )
        
        # Find best bet
        bet_recs = [r for r in recommendations if r.recommendation == "BET"]
        if bet_recs:
            best_bet = max(bet_recs, key=lambda x: x.expected_value)
            bet_recommendations.append({
                'date': match['Date'],
                'home': match['HomeTeam'],
                'away': match['AwayTeam'],
                'bet': best_bet
            })
        
        all_results.append({
            'date': match['Date'],
            'home': match['HomeTeam'],
            'away': match['AwayTeam'],
            'recommendations': recommendations
        })
    
    # Display results
    print("\nðŸ† BETTING RECOMMENDATIONS")
    print("=" * 40)
    
    if bet_recommendations:
        for i, match in enumerate(bet_recommendations, 1):
            bet = match['bet']
            print(f"\n{i}. ðŸŸ¢ {match['date']}")
            print(f"   ðŸŸï¸ {match['home']} vs {match['away']}")
            print(f"   âœ… BET: {bet.bet_type}")
            print(f"   ðŸ“Š Confidence: {bet.confidence:.1%}")
            print(f"   ðŸŽ¯ Adaptive Threshold: {bet.threshold:.1%}")
            print(f"   ðŸ’° Expected Value: {bet.expected_value:+.2%}")
            print(f"   ðŸ’¡ {bet.reasoning}")
    else:
        print("âŒ No high-confidence betting opportunities found")
    
    # Summary
    total = len(all_results)
    bets = len(bet_recommendations)
    
    print(f"\nðŸ“ˆ SUMMARY")
    print("=" * 15)
    print(f"ðŸŽ¯ Matches analyzed: {total}")
    print(f"âœ… BET recommendations: {bets} ({bets/total*100:.1f}%)")
    print(f"âŒ NO BET: {total-bets} ({(total-bets)/total*100:.1f}%)")
    
    if bet_recommendations:
        avg_conf = np.mean([m['bet'].confidence for m in bet_recommendations])
        avg_ev = np.mean([m['bet'].expected_value for m in bet_recommendations])
        print(f"ðŸ’Ž Average confidence: {avg_conf:.1%}")
        print(f"ðŸ’° Average expected value: {avg_ev:+.2%}")
    
    print(f"\nðŸš€ Enhanced with form weighting & adaptive thresholds!")


def main():
    parser = argparse.ArgumentParser(description='Simple Romanian Liga I date range predictor')
    parser.add_argument('--start', required=True, help='Start date (YYYY-MM-DD)')
    parser.add_argument('--end', required=True, help='End date (YYYY-MM-DD)')
    
    args = parser.parse_args()
    predict_date_range_matches(args.start, args.end)


if __name__ == "__main__":
    main()